package main

var codeTemplate string = `
//Code generated by go-validate tool; DO NOT EDIT.

import (
	"errors"
	"fmt"
	"reflect"
  	"strconv"
	"strings"
	"regexp"
)

type ValidationError struct {
  Field string
  Err error
}

var (
  	ErrLen = errors.New("length is incorrect")
  	ErrValidationMin = errors.New("Minimum error")
  	ErrValidationMax = errors.New("Maximum error")
  	ErrValidationContains = errors.New("Contain error")
  	ErrValidationRegexp = errors.New("Regex error")
	ErrValidationType = errors.New("Unsupported validation type")
)

func checkLen(field, str string, length int)(err ValidationError){
	if len(str) != length {
		return ValidationError{
				Field: field,
				Err: ErrLen,
			}
	} 
	return ValidationError{
				Field: field,
				Err: nil,
			}
}

func checkContains(typeField, val string, items string) (bool, error) {
	switch typeField {
	case "string":
		arr := strings.Split(items, ",")
		for _, item := range arr {
		  if item == val {
			  return true, nil
		  }
		}
		return false, nil
	case "int":
			arr := strings.Split(items, ",")
			intVal, err := strconv.Atoi(val)
			if err != nil {
					return false, err
			}
			for _, item := range arr {
				  result, err := strconv.Atoi(item)
				  if err != nil {
					return false, err
				  }
				  if result == intVal {
					  return true, nil
				  }
			  }
		return false, nil
	default:
		return false, ErrValidationType
	}
}

func checkMinMax(value interface{}, item int, typeOperation string) (bool, error){
	typeVal :=  reflect.TypeOf(value).Kind().String()
	intValue, ok := value.(int)
	if !ok {
		return false, ErrValidationType
	}
	if typeVal == "int" {
		switch typeOperation{
			case "min":
				if	intValue >= item {
					return true, nil
				}
				return false, nil
			case "max":
				if	intValue <= item {
					return true, nil
				} 
				return false, nil
		}
	}
	return false, ErrValidationType
}

{{ $global_map:= .NastedStructs }}

{{ range $key, $value := .NastedStructs }}
	{{ if gt (len $value) 0 }}
		func (model {{ $key }}) Validate() ([]ValidationError, error){
			var vErrors []ValidationError
			{{ range $value }} 
				{{ if not .IsStruct }}
					{{ if (index $global_map .Type) }}
						if vError, err := model.{{.Name}}.Validate(); len(vError) > 0 {
							vErrors = append(vErrors, vError[:]...)
						} else {
							return []ValidationError{}, err
						}
					{{ end }}

					{{ $name:= .Name }}
					{{ $parent:= .Parent }}
					{{ $is_array:= .IsArray }}
					{{ $type:= .Type }}
					{{ range $k, $v := .Validators }} 
						{{ if  eq $k "len" }}
							{{ if $is_array }}
								for _, item := range model.{{ range $parent }}{{.}}.{{end}}{{$name}} {
									errStruct := checkLen("{{$name}}", item, {{$v}})
									if errStruct.Err != nil {
										vErrors = append(vErrors, errStruct)
										break;
									}
								}
							{{ else }}
								errStruct := checkLen("{{$name}}", model.{{ range $parent }}{{.}}.{{end}}{{$name}}, {{$v}})
								if errStruct.Err != nil {
										vErrors = append(vErrors, errStruct)
									}
							{{ end }}
		
						{{ else if eq $k "regexp" }}
							re := regexp.MustCompile("{{$v}}")
							{{ if $is_array }}
								for _, item := range model.{{ range $parent }}{{.}}.{{end}}{{$name}} {
									if !re.Match([]byte(item)) {
										vError := ValidationError{Field: "{{$name}}", Err: ErrValidationRegexp}
										vErrors = append(vErrors, vError)
										break;
									}
								}
							{{ else }}
								if !re.Match([]byte(model.{{ range $parent }}{{.}}.{{end}}{{$name}})) {
									vError := ValidationError{Field: "{{$name}}", Err: ErrValidationRegexp}
									vErrors = append(vErrors, vError)
								}
							{{ end }}
						{{ else if eq $k "in" }}
							{
								var typeField string
								typeField = reflect.TypeOf(model.{{ range $parent }}{{.}}.{{end}}{{$name}}).Kind().String()
								{{ if $is_array }}
									for _, item := range model.{{ range $parent }}{{.}}.{{end}}{{$name}} {
										check, err := checkContains(typeField, item, "{{$v}}")
										if err != nil {
											return vErrors, err
										}
										if !check {
											vError := ValidationError{Field: "{{$name}}", Err: ErrValidationContains}
											vErrors = append(vErrors, vError)
										}
									}
								{{ else }}
									value := fmt.Sprint(model.{{ range $parent }}{{.}}.{{end}}{{$name}})
									check, err := checkContains(typeField, value, "{{$v}}")
									if err != nil {
										return vErrors, err
									}
									if !check {
										vError := ValidationError{Field: "{{$name}}", Err: ErrValidationContains}
										vErrors = append(vErrors, vError)
									}
								{{ end }}
							}
						{{ else if eq $k "min" }}
							{{ if $is_array }}
								{
									for _, item := range model.{{ range $parent }}{{.}}.{{end}}{{$name}} {
										ok, err := checkMinMax(item, {{$v}}, "min")
										if err != nil {
											return vErrors, err
										}
										if !ok {
											vError := ValidationError{Field: "{{$name}}", Err: ErrValidationMin}
											vErrors = append(vErrors, vError)
										}
									}
								}
							{{ else }}
								{
									ok, err := checkMinMax(model.{{ range $parent }}{{.}}.{{end}}{{$name}}, {{$v}}, "min")
									if err != nil {
										return vErrors, err
									}
									if !ok {
										vError := ValidationError{Field: "{{$name}}", Err: ErrValidationMin}
										vErrors = append(vErrors, vError)
									}
								}
							{{ end }}
						{{ else if eq $k "max" }}
							{{ if $is_array }}
								{
									for _, item := range model.{{ range $parent }}{{.}}.{{end}}{{$name}} {
										ok, err := checkMinMax(item, {{$v}}, "max")
										if err != nil {
											return vErrors, err
										}
										if !ok {
											vError := ValidationError{Field: "{{$name}}", Err: ErrValidationMax}
											vErrors = append(vErrors, vError)
										}
									}
								}
							{{ else }}
								{ 
									ok, err := checkMinMax(model.{{ range $parent }}{{.}}.{{end}}{{$name}}, {{$v}}, "max")
									if err != nil {
										return vErrors, err
									}
									if !ok {
										vError := ValidationError{Field: "{{$name}}", Err: ErrValidationMax}
										vErrors = append(vErrors, vError)
									}
								}
							{{ end }}
						{{ else }}
							vErrors = append(vErrors, ValidationError{Field: "{{$name}}", Err: ErrValidationType})
						{{ end }}
					{{end}}
				{{ end }}
				
			{{ end }}
		
			return vErrors, nil
		}
	{{ end }}
{{ end }}
`
